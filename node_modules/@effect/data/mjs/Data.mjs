/**
 * @since 1.0.0
 */
import * as Equal from "@effect/data/Equal";
import * as Hash from "@effect/data/Hash";
const protoArr = /*#__PURE__*/Object.assign( /*#__PURE__*/Object.create(Array.prototype), {
  [Hash.symbol]() {
    return Hash.array(this);
  },
  [Equal.symbol](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => Equal.equals(v, that[i]));
    } else {
      return false;
    }
  }
});
const protoStruct = {
  [Hash.symbol]() {
    return Hash.structure(this);
  },
  [Equal.symbol](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && Equal.equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
/**
 * @category constructors
 * @since 1.0.0
 */
export const struct = as => Object.assign(Object.create(protoStruct), as);
/**
 * @category constructors
 * @since 1.0.0
 */
export const unsafeStruct = as => Object.setPrototypeOf(as, protoStruct);
/**
 * @category constructors
 * @since 1.0.0
 */
export const tuple = (...as) => unsafeArray(as);
/**
 * @category constructors
 * @since 1.0.0
 */
export const array = as => unsafeArray(as.slice(0));
/**
 * @category constructors
 * @since 1.0.0
 */
export const unsafeArray = as => Object.setPrototypeOf(as, protoArr);
const _case = () => args => args === undefined ? Object.create(protoStruct) : struct(args);
export {
/**
 * Provides a constructor for the specified `Case`.
 *
 * @since 1.0.0
 * @category constructors
 */
_case as case };
/**
 * Provides a tagged constructor for the specified `Case`.
 *
 * @since 1.0.0
 * @category constructors
 */
export const tagged = tag => args => {
  const value = args === undefined ? Object.create(protoStruct) : struct(args);
  value._tag = tag;
  return value;
};
/**
 * Provides a Tagged constructor for a Case Class.
 *
 * @since 1.0.0
 * @category constructors
 */
export const TaggedClass = tag => {
  class Base extends Class {
    constructor() {
      super(...arguments);
      this._tag = tag;
    }
  }
  return Base;
};
/**
 * @since 1.0.0
 * @category constructors
 */
export class Structural {
  constructor(args) {
    if (args) {
      Object.assign(this, args);
    }
  }
  /**
   * @since 1.0.0
   */
  [Hash.symbol]() {
    return Hash.structure(this);
  }
  /**
   * @since 1.0.0
   */
  [Equal.symbol](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && Equal.equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
}
/**
 * Provides a constructor for a Case Class.
 *
 * @since 1.0.0
 * @category constructors
 */
export const Class = Structural;
/**
 * Create a constructor for a tagged union of `Data` structs.
 *
 * You can also pass a `TaggedEnum.WithGenerics` if you want to add generics to
 * the constructor.
 *
 * @example
 * import * as Data from "@effect/data/Data"
 *
 * const HttpError = Data.taggedEnum<
 *   | Data.Data<{ _tag: "BadRequest"; status: 400; message: string }>
 *   | Data.Data<{ _tag: "NotFound"; status: 404; message: string }>
 * >()
 *
 * const notFound = HttpError("NotFound")({ status: 404, message: "Not Found" })
 *
 * @example
 * import * as Data from "@effect/data/Data"
 *
 * type MyResult<E, A> = Data.TaggedEnum<{
 *   Failure: { error: E }
 *   Success: { value: A }
 * }>
 * interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {
 *   readonly taggedEnum: MyResult<this["A"], this["B"]>
 * }
 * const MyResult = Data.taggedEnum<MyResultDefinition>()
 *
 * const success = MyResult("Success")({ value: 1 })
 *
 * @category constructors
 * @since 1.0.0
 */
export const taggedEnum = () => tagged;
//# sourceMappingURL=Data.mjs.map